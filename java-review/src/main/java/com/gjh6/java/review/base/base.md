#### Base Review



##### key words

* private、protected、public和default的区别

|           | 包內  | 同包  | 子类   |  包外 |  
| :------   |:-----:|:-----:|:-----:|:-----:|     
| public    | √     | √     | √     | √     | 
| protected | √     | √     | √     | ×     |
| default   | √     | √     | ×     | ×     |
| private   | √     | ×     | ×     | ×     |

* static 关键词
    * 可以修饰类，变量，方法，静态方法和静态变量在类加载的过程中读入内存（事实上是方法区）常驻内存。**static变量所指向的内存引用，如果不把它设置为null，GC是永远不会回收这个对象的**
    * 被static修饰的类： 一般为静态内部类
    * 被static修的代码块：类加载时自动执行一次，一般用于配置文件加载
    * 被static修饰的变量：类加载时初始化，Class级别属性，全局只有一份不会随着实例增加了增多，获取赋值：类.属性名即可，不需要实例化。
    * 被static修饰的方法：类级别方法，在类第一次加载的时候被加载到内存中；静态方法只能调用静态变量和静态方法

* transient关键词
    * 仅实现Serializable接口的对象，如果属性被transient关键词休息，则对象实例在被序列化后，被transient修饰的属性，无法被序列化
    * 如果实现Externalizable接口的对象，实现了writeExternal 和 readExternal方法，则被实现的属性即使被transient修饰，也能被序列化
    
* volatile关键词
    * 保证共享变量线程可见，无法保证原子性
    * 线程执行时，先把变量从主内存，拷贝到工作内存（线程内存），操作完后写回主内存，如果多线程情况下共享一个变量不使用volatile修饰，可能导致数据异常。

* abstract
    * 抽象类不能实例化，即不能对其用new运算符； 
    * 类中如果有一个或多个abstract方法，则该类必须声明为abstract； 
    * 抽象类中的方法不一定都是abstract方法，它还可以包含一个或者多个具体的方法； 
    * 即使一个类中不含抽象方法，它也可以声明为抽象类； 
    * 抽象类中的抽象方法要被使用，必须由子类复写起所有的抽象方法后，建立子类对象调用。 
    * 如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。
    
* enum
    *  enum 的全称为 enumeration， 是 JDK 1.5  中引入的新特性，存放在 java.lang 包中。
    *  enum 是一个普通的 class， 可以定义一些属性和方法
    *  enum 不能使用 extends 关键字继承其他类，因为 enum 已经继承了 java.lang.Enum（java是单一继承）
    
* final
    * 当用final修饰一个类时，表明这个类不能被继承
    * 当用final修饰方法时，方法被锁定，以防任何继承类修改它的含义
    * 类的private方法会隐式地被指定为final方法
    * 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
    * 被final修饰的变量，会被当做编译器常量，在使用到此变量的地方会直接将变量替换为它的值，编译到class中，不需要动态链接
    
* finally
* instanceof
* native
* strictfp
* synchronized


* 集合类
* 并发包
* IO/NIO
* JVM
* 内存模型

* 泛型
* 异常
* 反射

